// src/index.ts
import { readFileSync, existsSync } from "fs";
var isObject = (v) => v !== null && typeof v === "object" && !Array.isArray(v);
var INVALID_PATH_CHARS_REGEX = /[<>:"|?*\n\r\t\f\x00-\x1F]/;
var GLOBSTAR_REGEX = /(?:^|\/)[*]{2}($|\/)/;
var MAX_PATH_LENGTH = 260 - 12;
var isValidPath = (input) => {
  if (typeof input === "string") {
    return input.length <= MAX_PATH_LENGTH && !INVALID_PATH_CHARS_REGEX.test(input);
  }
  return false;
};
var split = (str) => String(str).split(/\r\n?|\n/);
var isComment = (str) => str.startsWith("#");
var isParsed = (input) => isObject(input) && "patterns" in input && "sections" in input;
var patterns = (input) => {
  return split(input).map((l) => l.trim()).filter((line) => line !== "" && !isComment(line));
};
var parse = (input, options = {}) => {
  let filepath = options.path;
  if (isParsed(input)) return input;
  if (isValidPath(input) && existsSync(input)) {
    filepath = input;
    input = readFileSync(input);
  }
  const lines = split(input);
  const names = /* @__PURE__ */ new Map();
  const parsed = { sections: [], patterns: [] };
  let section = { name: "default", patterns: [] };
  let prev = null;
  for (const line of lines) {
    const value = line.trim();
    if (value.startsWith("#")) {
      const match = /^#+\s*(.*)\s*$/.exec(value);
      const name = match ? match[1] : "";
      if (prev) {
        names.delete(prev.name);
        prev.comment = prev.comment ? `${prev.comment}
${value}` : value;
        prev.name = name ? `${prev.name.trim()}
${name.trim()}` : prev.name.trim();
        names.set(prev.name.toLowerCase().trim(), prev);
        continue;
      }
      section = { name: name.trim(), comment: value, patterns: [] };
      names.set(section.name.toLowerCase(), section);
      parsed.sections.push(section);
      prev = section;
      continue;
    }
    if (value !== "") {
      section.patterns.push(value);
      parsed.patterns.push(value);
    }
    prev = null;
  }
  if (options.dedupe === true || options.unique === true) {
    return dedupe(parsed, { ...options, format: false });
  }
  parsed.path = filepath;
  parsed.input = Buffer.from(input.toString());
  const result = parsed;
  result.format = (opts = {}) => format(result, { ...options, ...opts });
  result.dedupe = (opts = {}) => dedupe(result, { ...options, ...opts });
  result.globs = (opts = {}) => globs(result, { path: filepath, ...options, ...opts });
  return result;
};
var parseFile = (filepath, options = {}) => {
  return parse(readFileSync(filepath, "utf8"), options);
};
var dedupe = (input, options = {}) => {
  const parsed = parse(input, { ...options, dedupe: false });
  const names = /* @__PURE__ */ new Map();
  const res = { sections: [], patterns: [] };
  const patternsSet = /* @__PURE__ */ new Set();
  let current;
  for (const section of parsed.sections) {
    const { name = "", comment, patterns: patterns2 } = section;
    const key = name.trim().toLowerCase();
    for (const pattern of patterns2) {
      patternsSet.add(pattern);
    }
    if (name && names.has(key)) {
      current = names.get(key);
      current.patterns = [...current.patterns, ...patterns2];
    } else {
      current = { name, comment, patterns: patterns2 };
      res.sections.push(current);
      names.set(key, current);
    }
  }
  for (const section of res.sections) {
    section.patterns = [...new Set(section.patterns)];
  }
  res.patterns = [...patternsSet];
  const result = res;
  result.format = (opts = {}) => format(result, { ...options, ...opts });
  result.dedupe = (opts = {}) => dedupe(result, { ...options, ...opts });
  result.globs = (opts = {}) => globs(result, { path: parsed.path, ...options, ...opts });
  return result;
};
var glob = (pattern, options) => {
  if (GLOBSTAR_REGEX.test(pattern)) {
    return pattern;
  }
  let relative = false;
  if (pattern.startsWith("/")) {
    pattern = pattern.slice(1);
    relative = true;
  } else if (pattern.slice(1, pattern.length - 1).includes("/")) {
    relative = true;
  }
  pattern += pattern.endsWith("/") ? "**/" : "/**";
  return relative ? pattern : `**/${pattern}`;
};
var globs = (input, options = {}) => {
  const parsed = parse(input, options);
  const result = [];
  let index = 0;
  const inputPatterns = parsed.patterns.concat(options.ignore || []).concat((options.unignore || []).map((p) => !p.startsWith("!") ? "!" + p : p));
  const push = (prefix, pattern) => {
    const prev = result[result.length - 1];
    const type = prefix ? "unignore" : "ignore";
    if (prev && prev.type === type) {
      if (!prev.patterns.includes(pattern)) {
        prev.patterns.push(pattern);
      }
    } else {
      result.push({ type, path: options.path || null, patterns: [pattern], index });
      index++;
    }
  };
  for (let pattern of inputPatterns) {
    let prefix = "";
    if (pattern.startsWith("!")) {
      pattern = pattern.slice(1);
      prefix = "!";
    }
    push(prefix, pattern.startsWith("/") ? pattern.slice(1) : pattern);
    push(prefix, glob(pattern));
  }
  return result;
};
var formatSection = (section = { name: "", patterns: [] }) => {
  const output = [section.comment || ""];
  if (section.patterns?.length) {
    output.push(section.patterns.join("\n"));
    output.push("");
  }
  return output.join("\n");
};
var format = (input, options = {}) => {
  const parsed = parse(input, options);
  const fn = options.formatSection || formatSection;
  const sections = parsed.sections || parsed;
  const output = [];
  for (const section of [].concat(sections)) {
    output.push(fn(section));
  }
  return output.join("\n");
};
var parseGitignore = parse;
parseGitignore.file = parseFile;
parseGitignore.parse = parse;
parseGitignore.dedupe = dedupe;
parseGitignore.format = format;
parseGitignore.globs = globs;
parseGitignore.formatSection = formatSection;
parseGitignore.patterns = patterns;
var index_default = parseGitignore;
export {
  dedupe,
  index_default as default,
  format,
  formatSection,
  globs,
  parse,
  parseFile,
  patterns
};
/*!
 * parse-gitignore-ts
 * TypeScript version of parse-gitignore <https://github.com/jonschlinkert/parse-gitignore>
 * Original Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
